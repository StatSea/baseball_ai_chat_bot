# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jTKuijiujoFABkVEI-RaZSWGUgSGlb9x
"""

# main.py
from __future__ import annotations

import re
import json
import os
import asyncio
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from fastapi import FastAPI, HTTPException, Query, Request
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
from sse_starlette.sse import EventSourceResponse  # pip install sse-starlette
import httpx



# =========================================================
# App (단 하나만!)
# =========================================================
app = FastAPI(title="KBO Relay Replay API", version="0.5.0")

# =========================================================
# CORS 설정 (프론트엔드: http://localhost:5500)
# - 브라우저에서 FastAPI(8000) 호출 허용
# =========================================================

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:5500",
        "http://127.0.0.1:5500",
        "https://baseball-ai-chat-bot-git-main-statseas-projects.vercel.app",
        # 커스텀 도메인 있으면 여기도 추가
    ],
    allow_credentials=False,   # 쿠키 안 쓰면 False로 두는 게 안전
    allow_methods=["*"],       # GET/POST/OPTIONS 포함
    allow_headers=["*"],       # Authorization, Content-Type 등 포함
)
# 파일 경로 기준(프로젝트 폴더 = main.py가 있는 폴더)
BASE_PATH = Path(__file__).resolve().parent
RAW_DIR = BASE_PATH / "data" / "raw"
PROCESSED_DIR = BASE_PATH / "data" / "processed"

# rules / cheers json 경로
RULES_PATH = PROCESSED_DIR / "rules_summary.json"
CHEERS_PATH = PROCESSED_DIR / "cheers.json"

# ✅ (추가) 선수 응원가 json 경로 (권장: project/data/player.json)
PLAYERS_PATH = BASE_PATH / "data" / "player.json"


# =========================================================
# 0) 규정/응원가 JSON 로드 + API
# =========================================================
class RuleItem(BaseModel):
    rule_key: str
    title: str
    short_def: str
    official_rule: str
    exception: Optional[str] = None


class CheerItem(BaseModel):
    team: str
    title: str
    url: str


RULES_DB: List[RuleItem] = []
_RULE_INDEX: Dict[str, RuleItem] = {}

CHEERS_DB: List[CheerItem] = []
_CHEERS_BY_TEAM: Dict[str, List[CheerItem]] = {}


def _norm(s: Optional[str]) -> str:
    return (s or "").strip().lower()


def _rebuild_rules_index():
    global _RULE_INDEX
    _RULE_INDEX = {r.rule_key.upper(): r for r in RULES_DB}


def _rebuild_cheers_index():
    global _CHEERS_BY_TEAM
    _CHEERS_BY_TEAM = {}
    for c in CHEERS_DB:
        team = (c.team or "").strip()
        _CHEERS_BY_TEAM.setdefault(team, []).append(c)


def load_rules_from_json(path: Path):
    global RULES_DB
    if not path.exists():
        raise FileNotFoundError(f"rules json not found: {path}")
    with path.open("r", encoding="utf-8") as f:
        raw = json.load(f)
    RULES_DB = [RuleItem(**item) for item in raw]
    _rebuild_rules_index()


def load_cheers_from_json(path: Path):
    global CHEERS_DB
    if not path.exists():
        raise FileNotFoundError(f"cheers json not found: {path}")
    with path.open("r", encoding="utf-8") as f:
        raw = json.load(f)
    CHEERS_DB = [CheerItem(**item) for item in raw]
    _rebuild_cheers_index()


# =========================================================
# 0-1) ✅ (추가) 선수 응원가 JSON 로드 + API
# =========================================================
class PlayerItem(BaseModel):
    # 최소 키들(없으면 검색/정렬이 어려워서 여기만 강제)
    team: str
    name: str

    # 나머지는 데이터마다 다를 수 있어서 optional
    teamKey: Optional[str] = None
    number: Optional[int] = None

    title: Optional[str] = None
    lyrics: Optional[str] = None

    # 링크/재생 정보 (형식이 다를 수 있어 optional)
    url: Optional[str] = None
    youtubeUrl: Optional[str] = None
    youtube_id: Optional[str] = None
    youtubeId: Optional[str] = None
    startTime: Optional[int] = None
    starttime: Optional[int] = None

    tip: Optional[str] = None
    position: Optional[str] = None

    model_config = {"extra": "allow"}  # JSON에 다른 필드가 있어도 받기


PLAYERS_DB: List[PlayerItem] = []
_PLAYERS_BY_TEAM: Dict[str, List[PlayerItem]] = {}


def _search_cheers_local(query: str) -> str:
    """
    Search for cheer songs in the local PLAYERS_DB based on the query.
    Returns a formatted string (like 'result' text).
    """
    if not query:
        return ""
    
    q_norm = query.replace(" ", "").lower()
    results = []

    # Simple keyword match in player name or title
    for p in PLAYERS_DB:
        p_name = (p.name or "").replace(" ", "").lower()
        p_title = (p.title or "").replace(" ", "").lower()
        
        if (p_name and p_name in q_norm) or (p_title and p_title in q_norm):
            song_info = f"[{p.team}] {p.name} 응원가"
            if p.title:
                song_info += f" - {p.title}"
            if p.lyrics:
                # Truncate lyrics if too long?
                song_info += f"\n가사: {p.lyrics}"
            if p.tip:
                song_info += f"\n팁: {p.tip}"
            if p.youtubeUrl:
                song_info += f"\nYouTube: {p.youtubeUrl}"
            
            results.append(song_info)
    
    # Check team chants (mocking for now unless there's a DB, assume generic team match)
    # If no results, maybe return generic
    
    if results:
        return "\n\n".join(results)
    return ""
_PLAYERS_BY_TEAMKEY_NUM: Dict[Tuple[str, int], PlayerItem] = {}


def _rebuild_players_index():
    global _PLAYERS_BY_TEAM, _PLAYERS_BY_TEAMKEY_NUM
    _PLAYERS_BY_TEAM = {}
    _PLAYERS_BY_TEAMKEY_NUM = {}

    for p in PLAYERS_DB:
        t = (p.team or "").strip()
        _PLAYERS_BY_TEAM.setdefault(t, []).append(p)

        # teamKey+number 조합이 있을 때만 단건 인덱스 생성
        if p.teamKey and p.number is not None:
            _PLAYERS_BY_TEAMKEY_NUM[(p.teamKey.strip().lower(), int(p.number))] = p


def load_players_from_json(path: Path):
    global PLAYERS_DB
    if not path.exists():
        raise FileNotFoundError(f"players json not found: {path}")
    with path.open("r", encoding="utf-8-sig") as f:
        raw = json.load(f)
    if not isinstance(raw, list):
        raise ValueError("player.json must be a list")
    PLAYERS_DB = [PlayerItem(**item) for item in raw]
    _rebuild_players_index()


@app.on_event("startup")
def on_startup():
    # JSON 로딩 (없으면 서버가 바로 죽게 해서 실수 빨리 발견)
    load_rules_from_json(RULES_PATH)
    load_cheers_from_json(CHEERS_PATH)

    # ✅ (추가) 선수 응원가 로딩
    load_players_from_json(PLAYERS_PATH)


# -------------------------
# RULES API
# (중요) /rules/search, /rules/keys 를 /rules/{rule_key} 위에!
# -------------------------
@app.get("/rules")
def list_rules():
    return {"count": len(RULES_DB), "items": [r.model_dump() for r in RULES_DB]}


@app.get("/rules/keys")
def list_rule_keys():
    keys = [r.rule_key for r in RULES_DB]
    return {"count": len(keys), "keys": keys}


@app.get("/rules/search")
def search_rules(q: str = Query(..., min_length=1)):
    query = _norm(q)
    out = []
    for r in RULES_DB:
        hay = " ".join(
            [
                _norm(r.rule_key),
                _norm(r.title),
                _norm(r.short_def),
                _norm(r.official_rule),
                _norm(r.exception or ""),
            ]
        )
        if query in hay:
            out.append(r.model_dump())
    return {"q": q, "count": len(out), "items": out}


@app.get("/rules/{rule_key}")
def get_rule(rule_key: str):
    k = (rule_key or "").strip().upper()
    if k in {"SEARCH", "KEYS"}:
        raise HTTPException(status_code=404, detail="reserved path")
    item = _RULE_INDEX.get(k)
    if not item:
        raise HTTPException(status_code=404, detail=f"rule_key not found: {rule_key}")
    return item.model_dump()


# -------------------------
# CHEERS API
# -------------------------
@app.get("/cheers")
def list_cheers():
    return {"count": len(CHEERS_DB), "items": [c.model_dump() for c in CHEERS_DB]}


@app.get("/cheers/teams")
def list_cheer_teams():
    teams = sorted(_CHEERS_BY_TEAM.keys())
    return {"count": len(teams), "teams": teams}


@app.get("/cheers/by_team/{team}")
def get_cheers_by_team(team: str):
    t = (team or "").strip()
    items = _CHEERS_BY_TEAM.get(t, [])
    if not items:
        raise HTTPException(status_code=404, detail=f"team not found: {team}")
    return {"team": t, "count": len(items), "items": [c.model_dump() for c in items]}


# ✅ (추가) LAAS 안정형: path param 검색
@app.get("/cheers/search/{text}")
def search_cheers_path(text: str, limit: int = Query(200, ge=1, le=1000)):
    t = (text or "").strip()

    # 1) 팀 모드: 팀명 정확 일치 => 해당 팀 전체 리스트
    if t in _CHEERS_BY_TEAM:
        items = _CHEERS_BY_TEAM.get(t, [])
        out = [c.model_dump() for c in items][:limit]
        return {"q": t, "mode": "team", "team": t, "count": len(out), "items": out}

    # 2) 타이틀 모드: title로만 검색
    query = _norm(t)
    out = []
    for c in CHEERS_DB:
        if query and query in _norm(c.title):
            out.append(c.model_dump())
            if len(out) >= limit:
                break

    return {"q": t, "mode": "title", "team": None, "count": len(out), "items": out}


@app.get("/cheers/search")
def search_cheers(
    q: str = Query(..., min_length=1),
    team: Optional[str] = Query(None),
    limit: int = Query(200, ge=1, le=1000),
):
    q_raw = (q or "").strip()
    team_filter = (team or "").strip() if team else None

    if team_filter:
        items = _CHEERS_BY_TEAM.get(team_filter, [])
        out = [c.model_dump() for c in items][:limit]
        return {"q": q_raw, "mode": "team", "team": team_filter, "count": len(out), "items": out}

    if q_raw in _CHEERS_BY_TEAM:
        items = _CHEERS_BY_TEAM[q_raw]
        out = [c.model_dump() for c in items][:limit]
        return {"q": q_raw, "mode": "team", "team": q_raw, "count": len(out), "items": out}

    query = _norm(q_raw)
    out = []
    for c in CHEERS_DB:
        if query and query in _norm(c.title):
            out.append(c.model_dump())
            if len(out) >= limit:
                break
    return {"q": q_raw, "mode": "title", "team": None, "count": len(out), "items": out}


# -------------------------
# ✅ PLAYERS API (선수 응원가)
# -------------------------
@app.get("/players")
def list_players(limit: int = Query(200, ge=1, le=5000)):
    items = [p.model_dump() for p in PLAYERS_DB][:limit]
    return {"count": len(PLAYERS_DB), "items": items}


@app.get("/players/teams")
def list_player_teams():
    teams = sorted(_PLAYERS_BY_TEAM.keys())
    return {"count": len(teams), "teams": teams}


@app.get("/players/by_team/{team}")
def get_players_by_team(team: str, limit: int = Query(500, ge=1, le=5000)):
    t = (team or "").strip()
    items = _PLAYERS_BY_TEAM.get(t, [])
    if not items:
        raise HTTPException(status_code=404, detail=f"team not found: {team}")
    out = [p.model_dump() for p in items][:limit]
    return {"team": t, "count": len(out), "items": out}


@app.get("/players/search/{text}")
def search_players_path(text: str, limit: int = Query(50, ge=1, le=1000)):
    t = (text or "").strip()

    if t in _PLAYERS_BY_TEAM:
        items = _PLAYERS_BY_TEAM.get(t, [])
        out = [p.model_dump() for p in items][:limit]
        return {"q": t, "mode": "team", "team": t, "count": len(out), "items": out}

    query = _norm(t)
    out = []
    for p in PLAYERS_DB:
        hay = " ".join(
            [
                _norm(p.team),
                _norm(p.teamKey),
                _norm(p.name),
                _norm(p.title),
                _norm(p.lyrics),
                _norm(p.tip),
                _norm(p.position),
            ]
        )
        if query and query in hay:
            out.append(p.model_dump())
            if len(out) >= limit:
                break
    return {"q": t, "mode": "search", "team": None, "count": len(out), "items": out}


@app.get("/players/search")
def search_players(q: str = Query(..., min_length=1), limit: int = Query(50, ge=1, le=1000)):
    return search_players_path(text=q, limit=limit)


@app.get("/players/{teamKey}/{number}")
def get_player(teamKey: str, number: int):
    key = (teamKey or "").strip().lower()
    try:
        num = int(number)
    except Exception:
        raise HTTPException(status_code=422, detail="number must be int")

    item = _PLAYERS_BY_TEAMKEY_NUM.get((key, num))
    if not item:
        raise HTTPException(status_code=404, detail="player not found (need teamKey+number in data)")
    return item.model_dump()


# =========================================================
# 1) relay 로더 (단일/멀티 이닝)
# =========================================================
RELAY_FILE_MAP: Dict[str, str] = {
    "20250801HHHT02025": str(RAW_DIR / "20250801HHHT02025_relay.json"),
}

EVENTS_CACHE: Dict[str, List[Dict[str, Any]]] = {}
SSE_QUEUES: Dict[str, List[asyncio.Queue]] = {}
TEAM_CACHE: Dict[str, Dict[str, str]] = {}


# ==============================
# ✅ (추가) lineup / matchup / onfield caches + helpers
# ==============================
LINEUP_CACHE: Dict[str, Dict[str, Any]] = {}        # game_id -> {"home": [...], "away": [...]}
PLAYER_NAME_CACHE: Dict[str, Dict[str, str]] = {}   # game_id -> {pcode: name}


def _relay_root(payload: Dict[str, Any]) -> Dict[str, Any]:
    """
    이 프로젝트 inning JSON 구조:
      payload["result"]["textRelayData"] 아래에 homeLineup/awayLineup/currentGameState 등이 존재
    """
    r = payload.get("result")
    if not isinstance(r, dict):
        return {}
    trd = r.get("textRelayData")
    return trd if isinstance(trd, dict) else {}


def _harvest_pcode_name(obj: Any, out: Dict[str, str]) -> None:
    """딕셔너리/리스트를 재귀로 훑으면서 (pcode, name) 쌍을 수집한다."""
    if isinstance(obj, dict):
        if "pcode" in obj and "name" in obj:
            pc = str(obj.get("pcode") or "").strip()
            nm = str(obj.get("name") or "").strip()
            if pc and nm:
                out[pc] = nm
        for v in obj.values():
            _harvest_pcode_name(v, out)
    elif isinstance(obj, list):
        for it in obj:
            _harvest_pcode_name(it, out)


def _get_pcode_to_name(game_id: str) -> Dict[str, str]:
    """game_id별 pcode->name 매핑을 만든다(캐시)."""
    if game_id in PLAYER_NAME_CACHE:
        return PLAYER_NAME_CACHE[game_id]

    payloads, _paths = load_payloads(game_id)
    p2n: Dict[str, str] = {}
    for p in payloads:
        root = _relay_root(p)
        _harvest_pcode_name(root, p2n)
        _harvest_pcode_name(p, p2n)

    PLAYER_NAME_CACHE[game_id] = p2n
    return p2n


def _get_lineups(game_id: str) -> Dict[str, Any]:
    """홈/원정 선발 라인업(타순/포지션/이름/pcode 포함)을 반환한다."""
    if game_id in LINEUP_CACHE:
        return LINEUP_CACHE[game_id]

    payloads, _paths = load_payloads(game_id)
    home: List[Dict[str, Any]] = []
    away: List[Dict[str, Any]] = []

    for p in payloads:
        root = _relay_root(p)
        hl = root.get("homeLineup") if isinstance(root, dict) else None
        al = root.get("awayLineup") if isinstance(root, dict) else None
        hb = hl.get("batter") if isinstance(hl, dict) else None
        ab = al.get("batter") if isinstance(al, dict) else None

        if isinstance(hb, list) and isinstance(ab, list) and (len(hb) > 0 or len(ab) > 0):
            home = hb
            away = ab
            break

    LINEUP_CACHE[game_id] = {"home": home, "away": away}
    return LINEUP_CACHE[game_id]


@dataclass
class ReplayMeta:
    index: int = 0
    running: bool = False
    interval: float = 10.0  # "한 이벤트당 몇 초"(가상 시간)


REPLAY_STATE: Dict[str, ReplayMeta] = {}
REPLAY_TASKS: Dict[str, asyncio.Task] = {}


def _read_json_file(path: str) -> Dict[str, Any]:
    if not os.path.exists(path):
        raise FileNotFoundError(path)
    with open(path, "r", encoding="utf-8-sig") as f:
        return json.load(f)


def _inning_file_paths(game_id: str) -> List[str]:
    paths: List[str] = []
    for inn in range(1, 10):
        p = str(RAW_DIR / f"{game_id}_inning{inn:02d}.json")
        if os.path.exists(p):
            paths.append(p)
    return paths


def _resolve_payload_paths(game_id: str) -> List[str]:
    inning_paths = _inning_file_paths(game_id)
    if inning_paths:
        return inning_paths

    single = RELAY_FILE_MAP.get(game_id)
    if single and os.path.exists(single):
        return [single]

    guess = str(RAW_DIR / f"{game_id}_relay.json")
    if os.path.exists(guess):
        return [guess]

    raise HTTPException(status_code=404, detail=f"no relay files found for game_id={game_id}")


def load_payloads(game_id: str) -> Tuple[List[Dict[str, Any]], List[str]]:
    paths = _resolve_payload_paths(game_id)
    payloads: List[Dict[str, Any]] = []

    for p in paths:
        try:
            payload = _read_json_file(p)
        except json.JSONDecodeError as e:
            raise HTTPException(status_code=500, detail=f"invalid json in {p}: {e}")
        except FileNotFoundError:
            raise HTTPException(status_code=404, detail=f"file not found: {p}")

        if "result" not in payload or not isinstance(payload["result"], dict):
            raise HTTPException(status_code=422, detail=f"invalid payload in {p}: missing result object")

        payloads.append(payload)

    return payloads, paths


# =========================================================
# 2) 이벤트 평탄화: result.textRelayData.textRelays 사용
# =========================================================
def flatten_events(payload: Dict[str, Any]) -> List[Dict[str, Any]]:
    r = payload["result"]
    trd = r.get("textRelayData", {})
    if not isinstance(trd, dict):
        raise HTTPException(status_code=422, detail="missing textRelayData")

    text_relays = trd.get("textRelays")
    if not isinstance(text_relays, list) or len(text_relays) == 0:
        raise HTTPException(
            status_code=422,
            detail=f"missing textRelayData.textRelays. textRelayData_keys={list(trd.keys())}",
        )

    events: List[Dict[str, Any]] = []

    for tr in text_relays:
        inn = tr.get("inn")
        home_away = tr.get("homeOrAway")

        options = tr.get("textOptions")
        if not isinstance(options, list) or len(options) == 0:
            seqno = tr.get("no") or tr.get("seqno")
            txt = tr.get("title") or tr.get("text") or ""
            events.append(
                {
                    "seqno": int(seqno) if str(seqno).isdigit() else seqno,
                    "inn": inn,
                    "homeOrAway": home_away,
                    "type": tr.get("statusCode") or tr.get("type"),
                    "text": txt,
                    "state": tr.get("currentGameState") or trd.get("currentGameState"),
                    "raw": tr,
                }
            )
            continue

        for opt in options:
            seqno = opt.get("seqno") or opt.get("seq") or opt.get("no") or tr.get("no")
            txt = opt.get("text") or opt.get("relayText") or ""
            ev_type = opt.get("type", tr.get("type"))

            cgs = opt.get("currentGameState") or tr.get("currentGameState") or trd.get("currentGameState")

            events.append(
                {
                    "seqno": int(seqno) if str(seqno).isdigit() else seqno,
                    "inn": inn,
                    "homeOrAway": home_away,
                    "type": ev_type,
                    "text": txt,
                    "state": cgs,
                    "raw": opt,
                }
            )

    def sort_key(ev: Dict[str, Any]):
        s = ev.get("seqno")
        return (0, s) if isinstance(s, int) else (1, str(s))

    events.sort(key=sort_key)
    return events


def _dedup_events(events: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    seen = set()
    out: List[Dict[str, Any]] = []
    for e in events:
        key = (e.get("seqno"), e.get("text"))
        if key in seen:
            continue
        seen.add(key)
        out.append(e)
    return out


def get_events(game_id: str) -> List[Dict[str, Any]]:
    if game_id in EVENTS_CACHE:
        return EVENTS_CACHE[game_id]

    payloads, _paths = load_payloads(game_id)

    merged: List[Dict[str, Any]] = []
    for p in payloads:
        merged.extend(flatten_events(p))

    merged.sort(key=lambda ev: (0, ev["seqno"]) if isinstance(ev.get("seqno"), int) else (1, str(ev.get("seqno"))))
    merged = _dedup_events(merged)

    EVENTS_CACHE[game_id] = merged

    if game_id not in REPLAY_STATE:
        REPLAY_STATE[game_id] = ReplayMeta(index=0, running=False, interval=10.0)

    TEAM_CACHE.pop(game_id, None)

    # ✅ lineup/name 캐시도 해당 game_id에서 새로 계산되도록 비움
    LINEUP_CACHE.pop(game_id, None)
    PLAYER_NAME_CACHE.pop(game_id, None)

    return merged


# =========================================================
# 3) state 구성
# =========================================================
def _safe_get(d: Any, *keys: str, default=None):
    cur = d
    for k in keys:
        if not isinstance(cur, dict) or k not in cur:
            return default
        cur = cur[k]
    return cur


def extract_scoreboard_from_state(cgs: Optional[Dict[str, Any]]) -> Dict[str, Any]:
    if not isinstance(cgs, dict):
        return {}
    sb = {
        "homeScore": _safe_get(cgs, "scoreBoard", "homeScore") or cgs.get("homeScore"),
        "awayScore": _safe_get(cgs, "scoreBoard", "awayScore") or cgs.get("awayScore"),
        "homeHit": _safe_get(cgs, "scoreBoard", "homeHit") or cgs.get("homeHit"),
        "awayHit": _safe_get(cgs, "scoreBoard", "awayHit") or cgs.get("awayHit"),
        "homeError": _safe_get(cgs, "scoreBoard", "homeError") or cgs.get("homeError"),
        "awayError": _safe_get(cgs, "scoreBoard", "awayError") or cgs.get("awayError"),
    }
    return {k: v for k, v in sb.items() if v is not None}


def extract_count_from_state(cgs: Optional[Dict[str, Any]]) -> Dict[str, Any]:
    if not isinstance(cgs, dict):
        return {}
    count = _safe_get(cgs, "count") or cgs.get("count") or {}
    if not isinstance(count, dict):
        count = {}
    return {
        "ball": count.get("ball", cgs.get("ball", "0")),
        "strike": count.get("strike", cgs.get("strike", "0")),
        "out": count.get("out", cgs.get("out", "0")),
    }


def extract_bases_from_state(cgs: Optional[Dict[str, Any]]) -> Dict[str, Any]:
    if not isinstance(cgs, dict):
        return {}
    bases = _safe_get(cgs, "bases") or cgs.get("bases") or {}
    if not isinstance(bases, dict):
        bases = {}
    return {
        "base1": bases.get("base1", cgs.get("base1", "0")),
        "base2": bases.get("base2", cgs.get("base2", "0")),
        "base3": bases.get("base3", cgs.get("base3", "0")),
    }


def inning_label(inn: Any, home_or_away: Any) -> str:
    if inn is None:
        return "?"
    top_bottom = "초" if str(home_or_away) in ("0", "T", "top", "TOP") else "말"
    return f"{inn}회{top_bottom}"


def _is_empty_base(v: Any) -> bool:
    return v in (None, "", "0", 0)


def bases_occupied(bases: Dict[str, Any]) -> List[str]:
    occ = []
    if not _is_empty_base(bases.get("base1")):
        occ.append("1루")
    if not _is_empty_base(bases.get("base2")):
        occ.append("2루")
    if not _is_empty_base(bases.get("base3")):
        occ.append("3루")
    return occ


def build_state(game_id: str) -> Dict[str, Any]:
    events = get_events(game_id)
    meta = REPLAY_STATE.get(game_id) or ReplayMeta()

    total = len(events)
    idx = max(0, min(meta.index, max(0, total - 1))) if total > 0 else 0

    last_event = events[idx] if total > 0 else None
    cgs = last_event.get("state") if isinstance(last_event, dict) else None

    inn = last_event.get("inn") if last_event else None
    hoa = last_event.get("homeOrAway") if last_event else None

    bases = extract_bases_from_state(cgs)

    return {
        "game_id": game_id,
        "replay": {
            "running": meta.running,
            "interval": meta.interval,
            "index": idx,
            "events_total": total,
            "inning": inn,
            "home_or_away": hoa,
            "inning_label": inning_label(inn, hoa),
        },
        "scoreboard": extract_scoreboard_from_state(cgs),
        "count": extract_count_from_state(cgs),
        "bases": bases,
        "bases_occupied": bases_occupied(bases),
        "last_event": {
            "seqno": last_event.get("seqno") if last_event else None,
            "type": last_event.get("type") if last_event else None,
            "text": last_event.get("text") if last_event else None,
        } if last_event else None,
    }


# =========================================================
# 3.5) 팀명 추출 + summary/commentary 텍스트
# =========================================================
def extract_teams_from_events(game_id: str) -> Dict[str, str]:
    if game_id in TEAM_CACHE:
        return TEAM_CACHE[game_id]

    events = get_events(game_id)
    away_team = None
    home_team = None

    pat = re.compile(r"(\S+)\s+공격")

    for e in events:
        txt = (e.get("text") or "").strip()
        hoa = str(e.get("homeOrAway") or "")
        m = pat.search(txt)
        if not m:
            continue

        team = m.group(1)
        if hoa == "0" and away_team is None:
            away_team = team
        elif hoa == "1" and home_team is None:
            home_team = team

        if away_team and home_team:
            break

    teams = {"away": away_team or "원정", "home": home_team or "홈"}
    TEAM_CACHE[game_id] = teams
    return teams


def format_team_score(scoreboard: Dict[str, Any], teams: Dict[str, str]) -> str:
    a = scoreboard.get("awayScore", "?")
    h = scoreboard.get("homeScore", "?")
    return f"스코어 {teams['away']} {a} - {h} {teams['home']}"


def format_count(count: Dict[str, Any]) -> str:
    b = count.get("ball", "0")
    s = count.get("strike", "0")
    o = count.get("out", "0")
    return f"B{b}-S{s}, {o}아웃"


def format_bases(bases: Dict[str, Any]) -> str:
    on = []
    if not _is_empty_base(bases.get("base1")):
        on.append("1루")
    if not _is_empty_base(bases.get("base2")):
        on.append("2루")
    if not _is_empty_base(bases.get("base3")):
        on.append("3루")
    return "주자: " + (", ".join(on) if on else "없음")


def state_to_sentence(state: Dict[str, Any], teams: Dict[str, str]) -> str:
    inning = state.get("replay", {}).get("inning_label", "?")
    sb = state.get("scoreboard", {})
    cnt = state.get("count", {})
    bases = state.get("bases", {})
    last = state.get("last_event", {}) or {}

    parts = [
        f"{inning}",
        format_team_score(sb, teams),
        format_count(cnt),
        format_bases(bases),
    ]
    if last.get("text"):
        parts.append(f"최근: {last['text']}")
    return " / ".join(parts)


# =========================================================
# 4) SSE
# =========================================================
async def broadcast_sse(game_id: str, data: Dict[str, Any]):
    queues = SSE_QUEUES.get(game_id, [])
    if not queues:
        return
    for q in list(queues):
        try:
            q.put_nowait(data)
        except Exception:
            pass


# =========================================================
# 5) replay loop
# =========================================================
async def replay_loop(game_id: str):
    while True:
        meta = REPLAY_STATE.get(game_id)
        if meta is None:
            return

        if not meta.running:
            await asyncio.sleep(0.1)
            continue

        events = get_events(game_id)
        if len(events) == 0:
            meta.running = False
            await asyncio.sleep(0.2)
            continue

        if meta.index >= len(events) - 1:
            meta.running = False
            await broadcast_sse(game_id, {"type": "state", "data": build_state(game_id)})
            await asyncio.sleep(0.2)
            continue


        meta.index += 1
        await broadcast_sse(game_id, {"type": "state", "data": build_state(game_id)})
        await asyncio.sleep(max(0.1, float(meta.interval)))


def ensure_replay_task(game_id: str):
    t = REPLAY_TASKS.get(game_id)
    if t and not t.done():
        return
    loop = asyncio.get_running_loop()
    REPLAY_TASKS[game_id] = loop.create_task(replay_loop(game_id))


# =========================================================
# 6) endpoints (relay)
# =========================================================
@app.get("/health")
async def health():
    return {
        "ok": True,
        "rules_count": len(RULES_DB),
        "cheers_count": len(CHEERS_DB),
        "players_count": len(PLAYERS_DB),
        "players_path": str(PLAYERS_PATH),
    }


@app.get("/games/{game_id}/debug/files")
async def debug_files(game_id: str):
    paths = _resolve_payload_paths(game_id)
    return {"game_id": game_id, "paths": paths}


@app.get("/games/{game_id}/raw")
async def raw(game_id: str, inning: Optional[int] = Query(None, ge=1, le=9)):
    payloads, _paths = load_payloads(game_id)

    if inning is not None:
        target = str(RAW_DIR / f"{game_id}_inning{inning:02d}.json")
        if os.path.exists(target):
            return JSONResponse(_read_json_file(target))
        return JSONResponse(payloads[0])

    return JSONResponse(payloads[0])


@app.get("/games/{game_id}/debug/keys")
async def debug_keys(game_id: str):
    payloads, paths = load_payloads(game_id)
    payload = payloads[0]

    top_keys = list(payload.keys())
    r = payload.get("result", {})
    result_keys = list(r.keys()) if isinstance(r, dict) else []
    trd = r.get("textRelayData", {}) if isinstance(r, dict) else {}
    trd_keys = list(trd.keys()) if isinstance(trd, dict) else []
    trd_text_relays_len = (
        len(trd.get("textRelays", []))
        if isinstance(trd, dict) and isinstance(trd.get("textRelays"), list)
        else 0
    )

    return {
        "paths_used": paths,
        "top_keys": top_keys,
        "result_keys": result_keys,
        "textRelayData_keys": trd_keys,
        "textRelayData.textRelays_len(first_payload)": trd_text_relays_len,
    }


@app.get("/games/{game_id}/events")
async def events_all(game_id: str, limit: int = Query(200, ge=1, le=5000)):
    events = get_events(game_id)
    return {"game_id": game_id, "total": len(events), "events": events[:limit]}


@app.get("/games/{game_id}/events/recent")
async def events_recent(game_id: str, n: int = Query(5, ge=1, le=50)):
    events = get_events(game_id)
    meta = REPLAY_STATE.get(game_id) or ReplayMeta()

    if not events:
        return {"game_id": game_id, "events": []}

    idx = max(0, min(meta.index, len(events) - 1))
    start = max(0, idx - (n - 1))
    recent = events[start: idx + 1]

    return {
        "game_id": game_id,
        "index": idx,
        "events": [
            {
                "seqno": e.get("seqno"),
                "type": e.get("type"),
                "inn": e.get("inn"),
                "homeOrAway": e.get("homeOrAway"),
                "text": e.get("text"),
            }
            for e in recent
        ],
    }


@app.get("/games/{game_id}/state")
async def state(game_id: str):
    get_events(game_id)
    return build_state(game_id)


# ==============================
# ✅ (추가) lineup / matchup / onfield endpoints
# ==============================

@app.get("/games/{game_id}/lineup")
async def lineup(game_id: str):
    """
    홈/원정 선발 라인업 반환
    - 근거: result.textRelayData.homeLineup/awayLineup.batter
    """
    get_events(game_id)
    lu = _get_lineups(game_id)
    return {
        "game_id": game_id,
        "lineup": lu,
        "counts": {"home": len(lu.get("home", []) or []), "away": len(lu.get("away", []) or [])},
    }


@app.get("/games/{game_id}/matchup")
async def matchup(game_id: str):
    """
    현재 투수/타자(pcode + name) 반환
    - 근거: last_event.state(currentGameState).pitcher/batter
    """
    get_events(game_id)
    events = get_events(game_id)
    meta = REPLAY_STATE.get(game_id) or ReplayMeta()

    if not events:
        return {"game_id": game_id, "matchup": {"pitcher": None, "batter": None}}

    idx = max(0, min(meta.index, len(events) - 1))
    last_event = events[idx]
    cgs = last_event.get("state") if isinstance(last_event, dict) else None
    if not isinstance(cgs, dict):
        return {"game_id": game_id, "matchup": {"pitcher": None, "batter": None}}

    p2n = _get_pcode_to_name(game_id)
    pitcher_pcode = str(cgs.get("pitcher") or "").strip()
    batter_pcode = str(cgs.get("batter") or "").strip()

    pitcher = {"pcode": pitcher_pcode, "name": p2n.get(pitcher_pcode)} if pitcher_pcode else None
    batter = {"pcode": batter_pcode, "name": p2n.get(batter_pcode)} if batter_pcode else None

    return {
        "game_id": game_id,
        "matchup": {
            "pitcher": pitcher,
            "batter": batter,
            "inning": last_event.get("inn"),
            "homeOrAway": last_event.get("homeOrAway"),
            "event_index": idx,
            "event_seqno": last_event.get("seqno"),
        },
    }


@app.get("/games/{game_id}/onfield")
async def onfield(game_id: str):
    """
    입문자 UX 기준 '지금 뛰는 선수들' 단순 제공:
    - 공격팀 라인업(9명)
    - 수비팀 현재 투수(1명)
    - 현재 타자(1명)
    """
    get_events(game_id)
    st = build_state(game_id)
    lu = _get_lineups(game_id)

    # matchup 재활용
    mu_resp = await matchup(game_id)
    mu = mu_resp.get("matchup", {}) if isinstance(mu_resp, dict) else {}

    home_or_away = str(st.get("replay", {}).get("home_or_away"))
    offense = "away" if home_or_away in ("0", "T", "top", "TOP") else "home"
    defense = "home" if offense == "away" else "away"

    return {
        "game_id": game_id,
        "offense_team_side": offense,
        "defense_team_side": defense,
        "offense_lineup": lu.get(offense, []),
        "defense_pitcher": mu.get("pitcher"),
        "current_batter": mu.get("batter"),
        "meta": {
            "inning_label": st.get("replay", {}).get("inning_label"),
            "count": st.get("count"),
            "bases": st.get("bases"),
        },
    }


@app.post("/games/{game_id}/replay/start")
async def replay_start(game_id: str, interval: float = Query(10.0, ge=0.1, le=60.0)):
    get_events(game_id)
    meta = REPLAY_STATE.get(game_id) or ReplayMeta()
    meta.interval = float(interval)
    meta.running = True
    REPLAY_STATE[game_id] = meta
    ensure_replay_task(game_id)
    return {"ok": True, "replay": meta.__dict__}


@app.post("/games/{game_id}/replay/pause")
async def replay_pause(game_id: str):
    get_events(game_id)
    meta = REPLAY_STATE.get(game_id) or ReplayMeta()
    meta.running = False
    REPLAY_STATE[game_id] = meta
    ensure_replay_task(game_id)
    return {"ok": True, "replay": meta.__dict__}


@app.post("/games/{game_id}/replay/seek")
async def replay_seek(game_id: str, index: int = Query(..., ge=0)):
    events = get_events(game_id)
    meta = REPLAY_STATE.get(game_id) or ReplayMeta()
    meta.index = min(index, max(0, len(events) - 1))
    REPLAY_STATE[game_id] = meta
    ensure_replay_task(game_id)
    return {"ok": True, "replay": meta.__dict__, "state": build_state(game_id)}


@app.post("/games/{game_id}/replay/reset")
async def replay_reset(game_id: str):
    get_events(game_id)
    REPLAY_STATE[game_id] = ReplayMeta(index=0, running=False, interval=10.0)
    ensure_replay_task(game_id)
    return {"ok": True, "replay": REPLAY_STATE[game_id].__dict__}


@app.get("/games/{game_id}/stream")
async def stream(game_id: str):
    get_events(game_id)
    ensure_replay_task(game_id)

    q: asyncio.Queue = asyncio.Queue(maxsize=100)
    SSE_QUEUES.setdefault(game_id, []).append(q)

    async def event_gen():
        yield {"event": "state", "data": json.dumps(build_state(game_id), ensure_ascii=False)}
        try:
            while True:
                msg = await q.get()
                if msg.get("type") == "state":
                    yield {"event": "state", "data": json.dumps(msg["data"], ensure_ascii=False)}
        finally:
            SSE_QUEUES[game_id] = [qq for qq in SSE_QUEUES.get(game_id, []) if qq is not q]

    return EventSourceResponse(event_gen())


@app.get("/games/{game_id}/summary")
async def summary(game_id: str):
    st = build_state(game_id)
    teams = extract_teams_from_events(game_id)
    return {"game_id": game_id, "teams": teams, "summary": state_to_sentence(st, teams), "state": st}


@app.get("/games/{game_id}/commentary")
async def commentary(game_id: str, n: int = Query(5, ge=1, le=20)):
    recent = await events_recent(game_id, n=n)
    texts = [e["text"] for e in recent.get("events", []) if e.get("text")]
    commentary_text = " / ".join(texts[-n:]) if texts else ""
    return {"game_id": game_id, "commentary": commentary_text, "recent": recent}


    return {"game_id": game_id, "q": q, "matches": hits, "count": len(hits)}


# =========================================================
# Proxy for Wanted LaaS (to avoid CORS)
# =========================================================
@app.post("/api/proxy/chat")
async def proxy_chat(request: Request):
    """
    Frontend -> FastAPI -> Wanted LaaS Preset proxy.

    Supports both payload styles from frontend:
      1) {"params": {...}, "messages": [...]}
      2) {"tone": "...", "fan_team": "...", "user_message": "..."}
    """
    body = await request.json()

    # 1) Load credentials from env (no hardcoding)
    api_key = os.getenv("WANTED_LAAS_API_KEY")
    project_id = os.getenv("WANTED_LAAS_PROJECT_ID")
    preset_hash = os.getenv("WANTED_LAAS_PRESET_HASH")

    if not api_key or not project_id or not preset_hash:
        raise HTTPException(
            status_code=500,
            detail="Missing env: WANTED_LAAS_API_KEY / WANTED_LAAS_PROJECT_ID / WANTED_LAAS_PRESET_HASH",
        )

    api_url = "https://api-laas.wanted.co.kr/api/preset/v2/chat/completions"

    # 2) Normalize incoming payload (params)
    params = body.get("params") or {}
    if "tone" in body and "tone" not in params:
        params["tone"] = body["tone"]
    if "fan_team" in body and "fan_team" not in params:
        params["fan_team"] = body["fan_team"]

    # 3) Normalize incoming payload (messages)
    messages = body.get("messages")
    if messages is None:
        user_message = body.get("user_message") or body.get("message") or ""
        messages = [{"role": "user", "content": user_message}] if user_message else []

    # 4) Build preset payload
    payload = {
        "hash": preset_hash,
        "params": params,
        "messages": messages,
    }

    headers = {
        "Content-Type": "application/json; charset=utf-8",
        "project": project_id,
        "apiKey": api_key,
    }

    async with httpx.AsyncClient() as client:
        resp = await client.post(api_url, json=payload, headers=headers, timeout=30.0)

    # 5) Return errors with debug info (so frontend can show details during dev)
    if resp.status_code != 200:
        return JSONResponse(
            status_code=resp.status_code,
            content={
                "error": "LaaS API Error",
                "status": resp.status_code,
                "body": resp.text,
                "sent_payload": payload,
            },
        )

    return resp.json()


# =========================================================
# Mount Static Files (Must be last)
# =========================================================
# Serve the project root directory as static files
# We mount to "/" but since API routes are defined first, they take precedence.
app.mount("/", StaticFiles(directory=str(BASE_PATH.parent), html=True), name="static")
